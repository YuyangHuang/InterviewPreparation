# C/C++

#### C和 C++ 区别
- 设计思想：C++面向对象，C面向过程
- 语法：
  - C++封装、继承、多态
  - C++相比C，增加许多类型安全的功能，如强制类型转换
  - C++支持范式编程，比如模板类、函数模板等


#### Strcpy
  - 源字符串const参数
  - 地址判断非null
  - 链式操作保存首地址

#### 野指针

- 成因
  - 指针变量未初始化
  - 指针释放后之后未置空
  - 指针操作超越变量作用域

#### Nginx负载均衡原理/机制

1. 轮询（默认）

2. 指定权重

3. IP绑定 ip_hash  
每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。

4. fair（第三方）  
按后端服务器的响应时间来分配请求，响应时间短的优先分配。

5. url_hash（第三方）  
按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。

### raii (?)

## C++与98版区别
#### C++智能指针 auto
- **原理**：
  - 智能指针本质上是一个类，可以通过将普通指针作为参数传入智能指针的构造函数实现绑定。
  - 通过运算符重载使得其使用方式与指针相同。
- **优势**：
  - 由于auto指针本身是一个类，所以创建时在栈上，故而创建出来的对象在出作用域的时候（函数/程序结束）会自己消亡，所以在类中写好析构函数就可以完成**智能的内存回收**。
  - **自动类型推断发生在编译期，所以使用auto并不会造成程序运行时效率的降低**
- **劣势**：
  - auto声明的变量必须要初始化，否则编译器不能判断变量的类型。
  - auto不能被声明为返回值，auto不能作为形参，auto不能被修饰为模板参数
  - 赋值时（`operator =`），赋值右边的变量内部指针会被release，若再在后面调用`_Right.func()`会导致crash（零指针） ：（附源码部分）
    ```
    问题代码：
    void TestAutoPtr2()
    {
      auto_ptr<Test> my_auto1 (new Test(1));
      if(my_auto1.get())
      {
          (*my_auto1).info_extend = "Test";    //先赋予一个初始值作为区别两个指针的标志
          
          auto_ptr<Test> my_auto2;
          my_auto2 = my_auto1;
          my_auto2->PrintSomething();            //打印发现成功转移
          my_auto1->PringSomething();            //**crash**
      }
    }

    原因：
    _Myt& operator=(_Myt& _Right) _THROW0()
		{	
      // assign compatible _Right (assume pointer)
      reset(_Right.release());
      return (*this);
    }

    _Ty *release() _THROW0()
		{	
      // return wrapped pointer and give up ownership
      _Ty *_Tmp = _Myptr;
      _Myptr = 0;   //**此时会置零**
      return (_Tmp);
		}

    ```
  - 一点源代码拓展：
  C++中的`explicit`关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为`implicit`(隐式)。  
  `class auto_ptr`中，显示构造函数只有`explicit auto_ptr(_Ty *_Ptr = 0) _THROW0() : _Myptr(_Ptr)`.

#### const / static
- const: 
  - 变量值无法被改变
  - 若在函数声明中，则形参不可在函数体中被改变，防止篡改
  - 若在类的成员函数（在函数最后加const），则类的成员变量不可被修改（相当于const类的this指针）
  - 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const
  - 成员函数返回值为const，防止函数放在“左值”。

- static:
  - 函数内：内存只被分配一次，下次call时依然用的是同一个变量
  - 模块内static变量：该模块都可使用，模块外不可
  - 模块内static函数：只可被这一模块内的其他函数调用，使用范围被限制在声明它的模块内
  - 类的static变量：所有类的对象共享一个变量
  - 类的static函数：改函数不接受this指针，故而只能访问类的static变量

#### 宏的使用
- 对于参数和整个宏，要用括号括起来
- 防止宏的副作用，对于参数，实行一比一代入，设计++操作很可能会自增多次
- 不能有`;`

#### C++中四种类型转换

- const_cast：用于将const变量转为非const
- static_cast：用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；
- dynamic_cast：用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。
  - 向上转换：指的是子类向基类的转换
  - 向下转换：指的是基类向子类的转换
  - 它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。

- reinterpret_cast：几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；

- **为什么不使用C的强制转换？**
  - C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。